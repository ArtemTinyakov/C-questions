1. Структура A хранит в себе ссылку на переменную a как указатель.
Структура B хранит указатель на переменную d.
При вызове cout << sizeof(A), следовательно, в консоль напечатается размер указателя на объект типа double (конкретное число зависит от архитектуры).
При вызове cout << sizeof(double&) в консоль напечатается размер объекта типа double (потому что по сути это просто другое имя объекта типа double) (конкретное число зависит от архитектуры).
При вызове cout << sizeof(B), как и при вызове cout << sizeof(double*), в консоль напечатается размер указателя на объект типа double (конкретное число зависит от архитектуры).

2. Тут нужно знать, как работает оператор [] и арифметику указателей.
При вызове оператора [] от ссылки, например int* a; a[3], по сути мы пишем выражение *(a + 3) (это просто реализация оператора [] для ссылок).
Операция "указатель + int" возвращает указатель на объект того же типа, но сам указатель сдвигается на int байт*размер типа вправо (если int < 0, то на |int| в лево, очевидно).
Поэтому выражение a[3] и 3[a] по сути означает одно и то же действие: *(a+3) и *(3+a).
Теперь про арифметику указателей: сложение указателей не определено; Вычитание указателей определено следующим образом: разность указателей на один и тот же тип возвращает количество байт/размер этого типа между указателями (в итоге получаем int).
Например &a[3] - &a[1] == 2.
Поэтому мы получаем следующее выражение: *(&a[1] - &a[3] + &a[12] - &a[6] + a) == *(1 - 3 + 12 - 6 + a) == *(4 + a) == a[4] == 5.

3. Тут всё просто: в цикле объявили i как ссылку на a, на каждой итерации проверяем выполнение условия i > 0 и если оно верно, выполняем операцию cout << a--;. Операция cout << a--; печатает значение переменной а, а потом уменьшает её значение на 1, следовательно, теперь и значение i тоже уменьшается на 1.
В итоге получаем вывод в консоли 321.
Казалось бы, всё должно произойти именно так, но есть подвох: после цикла for нет символа ;, поэтому телом цикла считается следующая инструкция, а именно return 0;. Т.к. выражение cout << a--; выполняется только после выполнения тела цикла, то в вывод ничего не напечатается и программа просто завершится на первой же итерации.

4. Здесь используется оператор запятая. Напоминание: оператор запятая гарантирует последовательное выполнение выражений слева направо, т.к. при записи a, b, c сначала вычисляется выражение a, затем выражение b, после этого выражение c и при этом оператор запятая возвращает значение, вычисленное самым правым выражением.
Таким образом получается, что строка x = (a, b) интерпретируется как x = b; (потому что по сути (a, b) это два выражение, разделенных оператором запятая, каждое из которых просто возвращает своё значение, а всё выражение (a, b) возвращает значение самого правого выражения, то есть b).
Строка y = a, b; интерпретируется как y = a;, т.к. тут оператор запятая разделяет две инструкции: y=a и b, при этом всё выражение возвращает значение b, но оно ничему не присваивается.
В итоге в консоли получаем вывод 20 10.

5. Тут в цикле for в момент проверки условия происходят две вещи: сначала вычисляется выражение i>>2>1, затем значение переменной i убавляется на 1.
Операция i>>2>1 происходит следующим образом: сначала выполняется побитовый сдвиг вправо на 2 бита переменной i, а затем вычисленное значение сравнивается с 1.
Побитовый сдвиг вправо на n единиц по сути делит число, которое сдвигают на 2^n.
Таким образом, на первой итерации проверяется условие 10>>2>1 == 10/4>1 == 2>1 == true. Затем i уменьшается на 1 и печатается 9. Далее то же самое происходит до тех пор, пока i не станет равным 7 (в этом случае 7>>2 == 1, т.к. тут происходит неявное приведение double к int, которое просто отбрасывает дробную часть double).
В итоге в консоль выводится 9 8 7.

6. Здесь видим две переопределенные функции print, принимающие в качестве параметров char const* (по сути указатель на char) и short.
Вызов print("abc") однозначен, вызывается первая функция. Вызов print('A') также однозначен, выбирается вторая функция. Вызов же print(0) не является однозначным, т.к. преобразование int к short происходит за одно действие (int -> short) и преобразование int к const char* происходит за одно действие, поэтому получаем CE (ошибку компиляции).

7. Во-первых, нужно знать, как число приводится к bool, а именно: 0 == false, любое ненулевое число == true.
Булевы операнды типа || (или), && (и) работают следующим образом: если встречается конструкция вида (a || b), гарантируется, что сначала вычислится значение a и если оно равно true, то b не будет вычисляться и вернется true; если встречается конструкция вида (a && b), то сначала вычисляется значение выражения a, и если оно равно false, то b не вычисляется.
Таким образом, получается, что выражение (++I || ++J && ++K) интерпретируется следующим образом: вычисляется ++I, I становится равным 2. Т.к. любое ненулевое число кастуется к bool как true и дальше идёт оператор ||, то вся конструкция (++I || ++J && ++K) возвращает true и выражения ++J и ++K не вычисляются и переменные J и K остаются равными 1.
true выводится в консоль как 1 (false выводится как 0).
Таким образом, получаем вывод 1211.

8. Здесь мы встречаемся с так называемым unspecified behavior, а именно: гарантируется, что любое выражение будет посчитано корректно, но не гарантируется порядок вычисления операндов.
Т.е. гарантируется, что a + b * c - d будет строго определенным, но не гарантируется, что операнды a, b, c, d вычислятся в определенном порядке. Поэтому нельзя сказать, что именно выведет в консоль выражение f() * (g() + g()) - это зависит от компилятора.

9. Здесь мы встречаемся с undefined behavior и RE (ошибкой времени выполнения).
При небольшом выходе за границу массива a[10] мы получаем ub (undefined behavior), т.к. язык С++ не следит за тем, вышли мы за границу или нет, а память недалеко от массива скорее всего доступна нашей программе и мы даже можем считать или записать по этому адресу что-нибудь.
Очень дальный выход за границу массива a[100000000] выдаст нам ошибку времени выполнения segmentation fault, т.к. мы обращаемся к недоступной памяти.

Отличие undefined behavior от unspecified behavior состоит в том, что в первом случае мы не знаем что именно происходит и результат будет неизвестен. Во втором случае мы так же не знаем деталей выполнения выражения, вызвавшего unspecified behavior, но результат выражения гарантирован.
undefined behavior - один из злейших врагов программиста, потому что не вызывает ошибок и, обычно, очень сложно отлавливается.

10. Объект типа signed char может принимать значения от -127 до 127 (по сути char хранит в себе целые числа, но каждое из этих чисел отвечает за определенный символ, закодированный по таблице ASCII).
В переменную a кладется символ a, которому соответствует номер 97, в переменную b кладется символ b, которому соответствует номер 98.
Сумма двух объектов типа char ни что иное, как сумма их номеров по таблице ASCII, поэтому в c мы получаем 97 + 98 == 195, что больше чем наибольшее возможное значение unsigned int == 127, поэтому мы получаем undefined behavior и не можем сказать, что выведется в консоль.

11. Здесь мы имеем дело с так называемой операцией promotion. Унарный оператор +, примененный к численному объекту выполняет над ним восходящее приведение, т.е. если тип а == char, то тип +a == int.
В итоге получаем вывод sizeof(char) и sizeof(int) (конкретные значения зависят от архитектуры).

12. Выражение int + unsigned int приводится к unsigned int, поэтому выражение x+y вернет не -1, а что-то непонятное (на самом деле понятное, если знать, как разные типы записываются в память).
Результат - некоторое положительное число, НЕ -1.

13. функция sizeof(а) не выполняет выражение а, а только смотрит на его тип. Поэтому sizeof(++x) не увеличит x на 1.
Вывод в консоль будет 0.

14. Вспоминая, что в выражениях не гарантируется, какой операнд вычисляется первым, получаем в данном случае undefined behavior.

15. Здесь используется тернарный оператор ?:. Он работает следующим образом: (condition ? expression1 : expression2) делает следующую вещь: если condition == true, то вычисляется и возвращается результат expression1, иначе - вычисляется и возвращается результат expression2.
Необходимо понимать, что expression1 и expression2 обязаны быть одного типа или приводимы к одному общему типу, иначе получим CE.
Также тернарный оператор можно ставить слева от оператора присваивания, но в этом случае необходимо, чтобы expression1 и expression2 возвращали lvalue.
В нашем случае: (2 < 3 ? ++x : x++) = 5; ++x возвращает lvalue, а x++ возвращает rvalue - копию х. Этот кусок кода не скомпилируется.
(2 < 3 ? ++x : x) = 5; ++x возвращает lvalue, x возвращает lvalue, этот код скомпилируется.
(2 < 3 ? ++x : x++); тернарный оператор не стоит слева от знака присваивания, поэтому в данном случае не важно, является ли expression1 и expression2 lvalue, смотрим только на типы возвращаемых значений expression1 и expression2 - оба int, этот код скомпилируется.

16. Здесь необходимо знать приоритеты операторов. Постфиксный инкремент имеет больший приоритет, чем префиксный, поэтому сначала выполняется именно он и ++x++ интерпретируется, как ++(x++).
Т.к. инкремент можно применять только к lvalue, а постфиксный инкремент возвращает rvalue, получаем CE.

17. Здесь просто нужно знать, что применение оператора delete к указателю на память, которая не была выделена с помощью оператора new является undefined behavior.

18. Оператор :: - это бинарный оператор, который используется для уточнения (квалификации) имен. Слева должна быть указана область видимости, а с правой стороны уточняемое имя (например, std::move()).
Если используется префиксный унарный оператор ::, то считается, что мы имеем в виду глобальную область видимости. Поэтому в данном случае ::x == 10 и никаких ошибок тут не будет.

19. Константную ссылку можно инициализировать rvalue выражением (например, числом или литералом: const int& a = 1;). При этом происходит так называемое lifetime expansion: пока не закончится область видимости ссылки на этот временный объект, сам объект не будет уничтожен - ссылка продляет ему жизнь.
Значит, кажется, функция f должна проинициализировать const int& a = 10 и в функции main переменная a станет равна 10. Но на самом деле, область видимости const int& a заканчивается сразу по окончании тела функции, поэтому происходит undefined behavior.
